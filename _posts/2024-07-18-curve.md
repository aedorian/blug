---
layout: post
date: 2024-07-18
---

[..](../index.html)

# Sonic's rail grinding mechanic in Unity

I wanted to try and recreate the rail grinding game mechanic from the Sonic series.

In the main games, every rail seems to be an individual asset created in another program.

Here, I'd like to make a procedural system that fits in Unity, is simple and fast to use. This way, rails could be prototyped and tested easily.

For some of the functions logic, I took inspiration from [this Catlike Coding tutorial](https://catlikecoding.com/unity/tutorials/curves-and-splines/) on splines.

# Bézier curves

<div class="sideside" markdown="1">
I decided to use cubic Bézier curves. These curves have 4 control points $P_i$. The curve starts at $P_0$ and ends at $P_3$. The problem is, as you can see the curve doesn't go through each of the 4 points (interpolation property).
{: .tleft }
<img src="../assets/img/curve/bezier.PNG" height=250px>
{: .imright }
</div>

Instead, we can use Bézier interpolation.

We have a set of $n$ points.
The idea is to create $n-1$ cubic Bézier curves in total, one between each point.

To fit each curve, we want to find the position of the two control points $P_1$ and $P_2$ in between the two points $P_0$ and $P_3$ we are trying to connect.

I'm not going to go into the math details, because [this Medium article by Omar Aflak](https://omaraflak.medium.com/b%C3%A9zier-interpolation-8033e9a262c2) already explains it very well.

But in the end, we have a matrix of the form $Ax = B$ to solve. Unity doesn't have a built-in linear algebra library, so I installed [Math.NET Numerics](https://numerics.mathdotnet.com/) using the [NuGet for Unity package manager](https://github.com/GlitchEnzo/NuGetForUnity/).

<figure style="display: inline-block">
<img src="../assets/img/curve/bezieryay.PNG" height=250px>
<figcaption>control points are shown in red and green</figcaption>
</figure>

Now I can just add another point wherever I want in the hierarchy and the curve is computed just fine. This allows for easy tweaking.

<figure style="display: inline-block">
<img src="../assets/img/curve/move.gif" height=250px>
</figure>

*Note: The only little problem is that it doesn't have local control. This means that changing a small portion of a curve can change the entire curve.*

<!--Of course, using a Bézier curve with configurable control points would have given us more control over its shape.-->

Then, I made a `Vector3 GetPoint(float t)` function (with `t` between 0 and 1) that returns a point of the curve. With a `N` variable that defines the number of points, we can start sampling the curve. Points are drawn using the `Gizmos.DrawSphere(position, radius)` function.

<figure style="display: inline-block">
<img src="../assets/img/curve/N50.PNG" width=650px>
<figcaption>N = 50</figcaption>
</figure>

<figure style="display: inline-block">
<img src="../assets/img/curve/N200.PNG" width=650px>
<figcaption>N = 200</figcaption>
</figure>






# Generating the mesh

Before computing the mesh, we still need two more functions to retrieve vectors for each point:

- <span color="yellow">The direction (or forward) vector.</span> We can get it using the first derivative $f’(t)$ of the Bézier curve equation.
- <span color="red">The up vector.</span> This will indicate on which side to position the player, and also the upper side of the rail.

*I'm sure there could be a way to calculate the up vector it using the direction vector (something perpendicular, for say). But to allow for more control, up vectors will be set manually by rotating the arrows.*

<figure style="display: inline-block">
<img src="../assets/img/curve/cool.PNG" height=300px>
<figcaption>forward and up vectors are visualized</figcaption>
</figure>

With that done, let's get into the mesh generation. I added a **Mesh Filter** and a **Mesh Renderer** component to the rail object.

<!-- All we have to do is build faces between each sampled point. -->

For each point of the curve, we obtain its $\vec{forward}$, $\vec{up}$ and $\vec{right}$ vectors (remember we can get the $\vec{right}$ vector as $\vec{forward} \wedge \vec{up}$). Using these vectors and the sampled point position, we add 4 new vertices to the mesh. Then, using the 4 vertices of the point that was sampled one step before, we construct 8 triangles.

<img src="../assets/img/curve/mesh3.png" height=200px>
<img src="../assets/img/curve/mesh2.png" height=200px>

<img src="../assets/img/curve/basicrail.PNG" height=300px>

And here are some rail meshes! I also added a `radius` variable to control their width.

Using submeshes and a different material, I made the upper face a different color to help visualize the up vector more clearly.

<img src="../assets/img/curve/upvector.PNG" height=300px>

Here's a simplified version of the function to create the mesh:

```cs
void GenerateMesh() {

    List<Vector3> verts = new List<Vector3>();
    
    List<int> triangles = new List<int>();
    List<int> upTriangles = new List<int>();      // vertices of the upper face
    
    int vertCount = 0;
    int[] prevVerts = new int[4];

    prevVerts[0] = -1;      // flag to indicate there isn't a previous point yet

    Mesh mesh = new Mesh { name = "railMesh" };

    for (int i = 0; i < N; i++) {

        Vector3 pos, front, right, up;
        float t = (float)i / N);

        pos = GetPoint(t);
        forward = GetVelocity(t).normalized * radius;
        up = GetUpVector(t).normalized * radius;
        right = Vector3.Cross(front, up).normalized * radius;

        // add new vertices
        verts.Add(pos - right - up); // bottom left
        verts.Add(pos - right + up); // top left
        verts.Add(pos + right - up); // bottom right
        verts.Add(pos + right + up); // top right

        // if we set it previously
        if (prevVerts[0] != -1) {

            // LEFT
            tris.Add(prevVerts[1]); tris.Add(vertCount + 1); tris.Add(vertCount);
            tris.Add(prevVerts[0]); tris.Add(prevVerts[1]); tris.Add(vertCount);

            // UP
            upTris.Add(vertCount + 1); upTris.Add(prevVerts[1]); upTris.Add(vertCount + 3);
            upTris.Add(prevVerts[1]); upTris.Add(prevVerts[3]); upTris.Add(vertCount + 3);

        }

        // set previous vertices
        prevVerts[0] = vertCount;
        prevVerts[1] = vertCount + 1;
        prevVerts[2] = vertCount + 2;
        prevVerts[3] = vertCount + 3;

        vertCount += 4;
    }

    mesh.subMeshCount = 2;

    mesh.vertices = verts.ToArray();
        
    mesh.SetTriangles(tris.ToArray(), 0);
    mesh.SetTriangles(upTris.ToArray(), 1);

    GetComponent<MeshFilter>().mesh = mesh;
}
```

# Gameplay

I modeled possibly the worst ripoff model ever made, gave it some animations and a simple movement script.

To make griding rails easier, I want to implement the *homing attack* mechanic first.

Basically, when a target is close, the player can jump towards it to destroy it.

<div class="sideside" markdown="1">
I implemented it using a trigger collider. When a valid target enters the collider, it is added to a `potentialTarget` list. When it leaves, it is removed from the list. A script is constantly looking for the closest target in the list, and defines it as the actual target. When the player jumps again when a target is available, it rushes towards it until it touches it, and destroys the target.
{: .tleft }
<img src="../assets/img/curve/hitbox.PNG" height=250px>
{: .imright }
</div>

<img src="../assets/img/curve/homing.gif" height=250px>

This will make it easier to start from the beginning of a rail instead of having to land exactly on it.

## Rail grinding

Once the player is on a rail, we just have to sample the curve at a `railProgress` variable (between 0 and 1), and add the up vector.

The player is rotated according to the up vector with `Quaternion.LookRotation(rail.GetUpVector(railProgress))`. The velocity force is also added at the end of the rail.

Here's how it looks:

<figure style="display: inline-block">
<img src="../assets/img/curve/slide.gif" height=250px>
<figcaption>grinding a loop</figcaption>
</figure>





Using I'd like to be able to make circular loops easily, therefore





Turns out we need to generate the entire curve to be able to sample from it after.

We have a set of points contained in a game object. I will first draw points from the curve in the `OnDrawGizmos()` function with `Gizmos.DrawSphere(position, size);`. A variable `N` is also there to define the number of points between each point.

Here's how it looks with linear interpolation:





# Adding straight lines

We want to be able to make circular loops, but also straight lines.


# References

Medium article by Omar Aflak I used for fitting the curve: https://omaraflak.medium.com/b%C3%A9zier-interpolation-8033e9a262c2

Also a very good tutorial for Unity splines by Catlike Coding: https://catlikecoding.com/unity/tutorials/curves-and-splines/

Video by [This video (at 2:34)](https://youtu.be/JwN43QAlF50?si=1U9rBgv3T5iWEish&t=154) on the differences between each type of curve pretty well.

Something we can try 


b splines or catmull rom

godot path 3D

ONLY ROTATE FOR A SINGLE ANGLE (degree around)

https://www.youtube.com/watch?v=JwN43QAlF50 2:46
https://lucidar.me/fr/mathematics/catmull-rom-splines/

jumping off and then landing back again on the right section

loop
spiral up or down

different camera angles (standing in one position and follow when fast)
homing attack
crouching
booster